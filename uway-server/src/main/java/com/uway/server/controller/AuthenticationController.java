package com.uway.server.controller;import com.uway.server.model.dto.AuthenticationRequest;import com.uway.server.model.dto.AuthenticationResponse;import com.uway.server.model.entity.User;import com.uway.server.model.entity.UserAddress;import com.uway.server.model.entity.UserOrder;import com.uway.server.repository.UserAddressRepository;import com.uway.server.repository.UserOrderRepository;import com.uway.server.repository.UserRepository;import com.uway.server.service.JwtUtil;import com.uway.server.service.MyUserDetailsService;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.BadCredentialsException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.web.bind.annotation.*;import javax.validation.Valid;import java.security.Principal;import java.util.List;@Slf4j@RestController@RequestMapping(produces = MediaType.APPLICATION_JSON_VALUE)@RequiredArgsConstructor@CrossOriginpublic class AuthenticationController {    private final AuthenticationManager authenticationManager;    private final MyUserDetailsService userDetailsService;    private final UserRepository userRepo;    private final UserAddressRepository userAddressRepo;    private final BCryptPasswordEncoder passwordEncoder;    private final JwtUtil jwtUtil;    private final UserOrderRepository orderRepo;    @RequestMapping(value = "/api/v1/authenticate", method = RequestMethod.POST)    public ResponseEntity<?> createAuthenticationToken(@RequestBody AuthenticationRequest authenticationRequest)            throws Exception {        try {            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(                    authenticationRequest.getUsername(), authenticationRequest.getPassword()));        } catch (BadCredentialsException e) {            throw new Exception("Incorrect Username or Password");        }        final UserDetails userDetails = userDetailsService.loadUserByUsername(authenticationRequest.getUsername());        final User user = userRepo.findUserByUsername(userDetails.getUsername());        final String jwt = jwtUtil.generateToken(userDetails);        return ResponseEntity.ok(new AuthenticationResponse(jwt, user));    }    @PreAuthorize("hasRole('ROLE_ADMIN')")    @GetMapping("/admin")    public String admin() {        return ("<h1>Welcome Admin");    }    @RequestMapping( value = "/api/v1/saveUser", method= RequestMethod.POST)    public void saveNewUser(@Valid @RequestBody User user) throws Exception {        boolean userExists = userRepo.existsByUsername(user.getUsername());        if (!userExists) {            try {                String password = user.getPassword();                String encryptPassword = passwordEncoder.encode(password);                user.setPassword(encryptPassword);                user.setEmail(user.getUsername()); //email address and username will be the same value.                user.setActive(true);                userRepo.save(user);            } catch (Exception e) {                e.printStackTrace();            }        } else {            throw new Exception("User Already Exists");        }    }    @CrossOrigin    @RequestMapping(value="/api/v1/authenticated/getAllUserPrincipalAddress", method=RequestMethod.GET)    public List<UserAddress> getAllUserAddress(Principal principal) {        User user = userRepo.findUserByUsername(principal.getName());        List<UserAddress> userAddressList = userAddressRepo.findAllUserAddressByUser(user);        for (UserAddress userAddress : userAddressList) {            userAddress.setUser(null);        }        return userAddressList;    }    @PostMapping("/api/v1/authenticated/saveUserPrincipalAddress")    public UserAddress saveUserAddress(@RequestBody UserAddress address, Principal principal) {        User user = userRepo.findUserByUsername(principal.getName());        address.setUser(user);        return userAddressRepo.save(address);    }    @GetMapping("/api/v1/authenticated/getAllUserPrincipalOrder")    public List<UserOrder> getAllUserOrder(Principal principal) {        User user = userRepo.findUserByUsername(principal.getName());        List<UserOrder> orderList = orderRepo.findAllUserOrderByUser(user);        for (UserOrder order : orderList) {            order.setUser(null);        }        return orderList;    }    @PostMapping("/api/v1/authenticated/saveUserPrincipalOrder")    public UserOrder saveUserOrder(@RequestBody UserOrder userOrder, Principal principal) {        User user = userRepo.findUserByUsername(principal.getName());        userOrder.setUser(user);        return orderRepo.save(userOrder);    }    @DeleteMapping("/api/v1/authenticated/deleteUserPrincipalAddress")    public List<UserAddress> deleteUserPrincipalAddress(@RequestBody UserAddress userAddress, Principal principal) {        User user = userRepo.findUserByUsername(principal.getName());        userAddress.setUser(user);        userAddressRepo.delete(userAddress);        List<UserAddress> addressList = userAddressRepo.findAllUserAddressByUser(user);        for (UserAddress address : addressList) {            address.setUser(null);        }        return addressList;    }}